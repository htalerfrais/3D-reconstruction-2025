%% Localisation

Idée générale - 
On a : 
	-les points 3D reconstruits des images précédentes (Uw)
	-une nouvelle image qui contient des observations 2D de certains points de Uw
On veut :
	-calculer la position de la caméra de la nouvelle image (initialisée à celle de
	 la caméra de l'image précédente par l'hypothèse que les images se suivent) SANS
	 changer les points 3D (Uw)
	-projeter les points 3D dans la nouvelle caméra et calculer l'erreur de
	 reprojection

En d'autres mots, c'est un Bundle Adjustment mais pour la Pose uniquement

On travaille donc à partir de la classe BA_LM_schur, et on commente les lignes qui 
changent les points 3D (Uw) dans l'étape d'optimisation, et on forme BA_LM_localisation

Code -
Xw = Uw[p3D_keys_to_ids[common_keys]]
On veut récupérer les points 3D visibles dans la nouvelle image (déjà fait plus haut
mais on le refait pour que ce soit clair pour le moment). Donc on prend dans Uw tous les
points associés aux common_keys (on doit passer par la correspondance p3D_keys_to_ids car
Uw fonctionne avec les ids.

local_p3D_keys_to_ids = np.arange(len(common_keys))
Système d'indexation local pour le BA de la nouvelle caméra
Chaque point 3D a un indice local unique pour la caméra

p_loc = [p[new_im_id]]
P : liste des points 2D pour chaque image. Pour la localisation, on ne fait le BA que sur
la nouvelle caméra donc on ne prend que les points 2D de la dernière image, et on les met dans une liste car BA_LM_localization étant dérivée de BA_LM_schur elle attend une liste 
d'images (même s'il n'y en a qu'une).
Donc p_loc : coordonnées 2D observées dans la nouvelle image seulement.

tracks_loc = [{
    'p3D_keys': local_p3D_keys_to_ids,
    'p2D_ids': tracks_full[new_im_id]['p2D_ids'][idsNew][mask]
}]
tracks_loc : correspondance entre les points 3D de Uw et les points 2D de la nouvelle image.

BA_loc = BA_LM_localization(
    [Mwc_guess],
    Xw,
    local_p3D_keys_to_ids,
    tracks_loc,
    K,
    p_loc
)
BA pour la localisation

Mwc_new = BA_loc.getPoses()[0]
.getPoses() renvoie une liste de positions de caméras sous formes des matrices (4,4).
On a qu'une caméra donc on prend la première.

Mwc.append(Mwc_new)
On ajoute la position déterminée de la nouvelle	caméra à la liste des positions des caméras.

Ensuite :
	-on décompose la matrice de position en les matrices de rotation et translation
	-on recalcule la position des points 3D vus par la caméra (Uc)
	-on calcule l'erreur de reproduction
	-on affiche le résultat